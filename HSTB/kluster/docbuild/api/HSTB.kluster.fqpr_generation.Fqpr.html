
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Fqpr &#8212; kluster 1.0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="fqpr_project module" href="../kluster_api/fqpr_project.html" />
    <link rel="prev" title="validate_kluster_input_datum" href="HSTB.kluster.fqpr_generation.validate_kluster_input_datum.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="fqpr">
<h1>Fqpr<a class="headerlink" href="#fqpr" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">HSTB.kluster.fqpr_generation.</span></span><span class="sig-name descname"><span class="pre">Fqpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multibeam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">motion_latency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">HSTB.kluster.backends._zarr.ZarrBackend</span></code></p>
<p>Fully qualified ping record: contains all records built from the raw MBES file and supporting data files.  Built
around the BatchRead engine which supplies the multibeam data conversion.</p>
<p>Fqpr processing is built using the method detailed in “Application of Surface Sound Speed Measurements in
Post-processing for Multi-Sector Multibeam Echosounders” by J.D. Beaudoin and John Hughes Clarke</p>
<div class="line-block">
<div class="line">Processing consists of five main steps:</div>
<div class="line">Fqpr.read_from_source - run xarray_conversion to get xarray Datasets for ping/attitude/navigation records</div>
<div class="line">Fqpr.get_orientation_vectors - Build transmit/receive unit vectors rotated by attitude and mounting angle</div>
<div class="line">Fqpr.get_beam_pointing_vectors - Correct sonar relative beam angles by orientation to get corrected</div>
<div class="line-block">
<div class="line">beam pointing vectors and azimuths</div>
</div>
<div class="line">Fqpr.sv_correct - Use the corrected beam vectors, travel time and sound velocity profile to ray trace the beams</div>
<div class="line">Fqpr.georef_xyz - Using pyproj, transform the vessel relative offsets to georeferenced xyz</div>
</div>
<p>See fqpr_convenience.convert_multibeam, process_multibeam and perform_all_processing for example use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>multibeam</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<a class="reference internal" href="HSTB.kluster.xarray_conversion.BatchRead.html#HSTB.kluster.xarray_conversion.BatchRead" title="HSTB.kluster.xarray_conversion.BatchRead"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchRead</span></code></a>]) – instance of xarray_conversion BatchRead class</p></li>
<li><p><strong>motion_latency</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – optional motion latency adjustment</p></li>
<li><p><strong>address</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – passed to dask_find_or_start_client to setup dask cluster</p></li>
<li><p><strong>show_progress</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If true, uses dask.distributed.progress.  Disabled for GUI, as it generates too much text</p></li>
<li><p><strong>parallel_write</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will write in parallel to disk</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Attributes Summary</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.has_sbet" title="HSTB.kluster.fqpr_generation.Fqpr.has_sbet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_sbet</span></code></a></p></td>
<td><p>True if an SBET has been imported into this FQPR instance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.input_datum" title="HSTB.kluster.fqpr_generation.Fqpr.input_datum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">input_datum</span></code></a></p></td>
<td><p>The basic input datum of the converted multibeam data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.last_operation_date" title="HSTB.kluster.fqpr_generation.Fqpr.last_operation_date"><code class="xref py py-obj docutils literal notranslate"><span class="pre">last_operation_date</span></code></a></p></td>
<td><p>Get the datetime of the last operation performed on this fqpr instance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.max_time" title="HSTB.kluster.fqpr_generation.Fqpr.max_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_time</span></code></a></p></td>
<td><p>Get the nicely formatted time in UTC for the end time of this fqpr object</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.min_time" title="HSTB.kluster.fqpr_generation.Fqpr.min_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_time</span></code></a></p></td>
<td><p>Get the nicely formatted time in UTC for the start time of this fqpr object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.number_of_heads" title="HSTB.kluster.fqpr_generation.Fqpr.number_of_heads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_heads</span></code></a></p></td>
<td><p>Get the number of sonar heads for the sonar in this FQPR instance</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.number_of_pings" title="HSTB.kluster.fqpr_generation.Fqpr.number_of_pings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_pings</span></code></a></p></td>
<td><p>Get the number of pings for the sonar in this FQPR instance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.sbet_navigation" title="HSTB.kluster.fqpr_generation.Fqpr.sbet_navigation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sbet_navigation</span></code></a></p></td>
<td><p>Return the sbet navigation for the first sonar head.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.sonar_model" title="HSTB.kluster.fqpr_generation.Fqpr.sonar_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sonar_model</span></code></a></p></td>
<td><p>Get the sonar type from the ping record</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.status" title="HSTB.kluster.fqpr_generation.Fqpr.status"><code class="xref py py-obj docutils literal notranslate"><span class="pre">status</span></code></a></p></td>
<td><p>Get the processing status of the Fqpr</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Summary</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.calc_max_var" title="HSTB.kluster.fqpr_generation.Fqpr.calc_max_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_max_var</span></code></a>([varname])</p></td>
<td><p>For given variable, return the maximum value found across all sectors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.calc_min_var" title="HSTB.kluster.fqpr_generation.Fqpr.calc_min_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_min_var</span></code></a>([varname])</p></td>
<td><p>For given variable, return the minimum value found across all sectors</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.calculate_total_uncertainty" title="HSTB.kluster.fqpr_generation.Fqpr.calculate_total_uncertainty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_total_uncertainty</span></code></a>([subset_time, ...])</p></td>
<td><p>Use the tpu module to calculate total horizontal uncertainty and total vertical uncertainty for each sounding.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.close" title="HSTB.kluster.fqpr_generation.Fqpr.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a>([close_dask])</p></td>
<td><p>Must forcibly close the logging handlers to allow the data written to disk to be moved or deleted.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.construct_crs" title="HSTB.kluster.fqpr_generation.Fqpr.construct_crs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct_crs</span></code></a>([epsg, datum, projected, vert_ref])</p></td>
<td><p>Build pyproj crs from several different options, used with georef_across_along_depth.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.copy" title="HSTB.kluster.fqpr_generation.Fqpr.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Return a copy of this Fqpr instance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.determine_altitude_corr" title="HSTB.kluster.fqpr_generation.Fqpr.determine_altitude_corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determine_altitude_corr</span></code></a>(alt, raw_att, ...)</p></td>
<td><p>We use the nav as provided by the POSMV.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.determine_induced_heave" title="HSTB.kluster.fqpr_generation.Fqpr.determine_induced_heave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determine_induced_heave</span></code></a>(ra, hve, raw_att, ...)</p></td>
<td><p>From Kongsberg datagram doc: Note that heave is displayed and logged as positive downwards (the sign is changed) including roll and pitch induced lever arm translation to the system’s transmit transducer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.export_dataset" title="HSTB.kluster.fqpr_generation.Fqpr.export_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_dataset</span></code></a>(dataset_name, dest_path)</p></td>
<td><p>Run the export module to export each variable in the given dataset to one csv, writing to the provided path, see export.export_dataset_to_csv</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.export_lines_to_file" title="HSTB.kluster.fqpr_generation.Fqpr.export_lines_to_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_lines_to_file</span></code></a>([linenames, ...])</p></td>
<td><p>Run the export module to export only the data belonging to the given lines to file, see export.export_lines_to_file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.export_pings_to_file" title="HSTB.kluster.fqpr_generation.Fqpr.export_pings_to_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_pings_to_file</span></code></a>([output_directory, ...])</p></td>
<td><p>Run the export module to export point cloud relevant data to file, see export.export_pings_to_file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.export_soundings_to_file" title="HSTB.kluster.fqpr_generation.Fqpr.export_soundings_to_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_soundings_to_file</span></code></a>(datablock[, ...])</p></td>
<td><p>Run the export module to export given soundings to file, see export.export_soundings_to_file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.export_tracklines_to_file" title="HSTB.kluster.fqpr_generation.Fqpr.export_tracklines_to_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_tracklines_to_file</span></code></a>([linenames, ...])</p></td>
<td><p>Run the export module to export the navigation to vector file, see export.export_tracklines_to_file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.export_variable" title="HSTB.kluster.fqpr_generation.Fqpr.export_variable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_variable</span></code></a>(dataset_name, var_name, ...)</p></td>
<td><p>Run the export module to export the given variable to csv, writing to the provided path, see export.export_variable_to_csv</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.generate_starter_orientation_vectors" title="HSTB.kluster.fqpr_generation.Fqpr.generate_starter_orientation_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_starter_orientation_vectors</span></code></a>([txrx, ...])</p></td>
<td><p>Take in identifiers to find the correct xyzrph entry, and use the heading value to figure out if the transmitter/receiver (tx/rx) is oriented backwards.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.georef_xyz" title="HSTB.kluster.fqpr_generation.Fqpr.georef_xyz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">georef_xyz</span></code></a>([subset_time, prefer_pp_nav, ...])</p></td>
<td><p>Use the raw attitude/navigation to transform the vessel relative along/across/down offsets to georeferenced soundings.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.get_beam_pointing_vectors" title="HSTB.kluster.fqpr_generation.Fqpr.get_beam_pointing_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_beam_pointing_vectors</span></code></a>([subset_time, ...])</p></td>
<td><p>Beam pointing vector is the beam specific vector that arises from the intersection of the tx ping and rx cone of sensitivity.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.get_cluster_params" title="HSTB.kluster.fqpr_generation.Fqpr.get_cluster_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cluster_params</span></code></a>()</p></td>
<td><p>Attempt to figure out what the chunk size and number of chunks at a time parameters should be given the dims of the dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.get_orientation_vectors" title="HSTB.kluster.fqpr_generation.Fqpr.get_orientation_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_orientation_vectors</span></code></a>([subset_time, ...])</p></td>
<td><p>Using attitude angles, mounting angles, build the tx/rx vectors that represent the orientation of the tx/rx at time of transmit/receive.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.get_variable_by_filter" title="HSTB.kluster.fqpr_generation.Fqpr.get_variable_by_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_variable_by_filter</span></code></a>(var_name[, ...])</p></td>
<td><p>ping_filter is set upon selecting points in 2d/3d in Kluster.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.import_post_processed_navigation" title="HSTB.kluster.fqpr_generation.Fqpr.import_post_processed_navigation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">import_post_processed_navigation</span></code></a>(navfiles[, ...])</p></td>
<td><p>Load from post processed navigation files (currently just SBET and SMRMSG) to get lat/lon/altitude as well as 3d error for further processing.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.import_sound_velocity_files" title="HSTB.kluster.fqpr_generation.Fqpr.import_sound_velocity_files"><code class="xref py py-obj docutils literal notranslate"><span class="pre">import_sound_velocity_files</span></code></a>(src[, ...])</p></td>
<td><p>Load to self.cast_files the file paths to the sv casts of interest.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.initial_att_interpolation" title="HSTB.kluster.fqpr_generation.Fqpr.initial_att_interpolation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initial_att_interpolation</span></code></a>()</p></td>
<td><p>We provide as an optional step in self.get_orientation_vectors (or run separately) the ability to interpolate the raw attitude and navigation to the ping record times and save these records to disk.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.initialize_intermediate_data" title="HSTB.kluster.fqpr_generation.Fqpr.initialize_intermediate_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_intermediate_data</span></code></a>(sec_ident, ky)</p></td>
<td><p>self.intermediate_dat is the storage for all the futures generated by the main processes (get_orientation_vectors, get_beam_pointing_vectors, etc.).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.initialize_log" title="HSTB.kluster.fqpr_generation.Fqpr.initialize_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_log</span></code></a>()</p></td>
<td><p>Initialize the fqpr logger using the multibeam logfile attribute.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.interp_to_ping_record" title="HSTB.kluster.fqpr_generation.Fqpr.interp_to_ping_record"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interp_to_ping_record</span></code></a>(sources[, attributes])</p></td>
<td><p>Take in a dataset that is not at ping time (raw navigation, attitude, etc.) and interpolate it to ping time and save it to the raw ping datasets.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.intersects" title="HSTB.kluster.fqpr_generation.Fqpr.intersects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersects</span></code></a>(min_y, max_y, min_x, max_x[, ...])</p></td>
<td><p>Check if the provided extents intersect with this fqpr instance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.is_processed" title="HSTB.kluster.fqpr_generation.Fqpr.is_processed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_processed</span></code></a>([in_depth])</p></td>
<td><p>Kluster maintains two records for processing status.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.line_attributes" title="HSTB.kluster.fqpr_generation.Fqpr.line_attributes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">line_attributes</span></code></a>(line_name)</p></td>
<td><p>Attributes by line are added after conversion to the ping attribution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.line_is_processed" title="HSTB.kluster.fqpr_generation.Fqpr.line_is_processed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">line_is_processed</span></code></a>(line_name)</p></td>
<td><p>If line is processed, the TVU will not be all NaN in the middle of the line.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.overwrite_raw_navigation" title="HSTB.kluster.fqpr_generation.Fqpr.overwrite_raw_navigation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overwrite_raw_navigation</span></code></a>(navfiles, ...[, ...])</p></td>
<td><p>Load from raw navigation files (currently just POS MV .000) to get lat/lon/altitude.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.read_from_source" title="HSTB.kluster.fqpr_generation.Fqpr.read_from_source"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_source</span></code></a>([build_offsets])</p></td>
<td><p>Activate rawdat object's appropriate read class</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.remove_post_processed_navigation" title="HSTB.kluster.fqpr_generation.Fqpr.remove_post_processed_navigation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_post_processed_navigation</span></code></a>()</p></td>
<td><p>import_post_processed_navigation will write navigation and navigation related attributes to the Fqpr instance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.remove_profile" title="HSTB.kluster.fqpr_generation.Fqpr.remove_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_profile</span></code></a>(profile_name)</p></td>
<td><p>Sound velocity profiles are stored in the Fqpr datastore as attributes with the 'profile_timestamp' format, ex: 'profile_1503411780'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.restore_subset" title="HSTB.kluster.fqpr_generation.Fqpr.restore_subset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">restore_subset</span></code></a>()</p></td>
<td><p>Restores the original data if subset_by_time has been run.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_additional_xyz_offsets" title="HSTB.kluster.fqpr_generation.Fqpr.return_additional_xyz_offsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_additional_xyz_offsets</span></code></a>(ra, prefixes, ...)</p></td>
<td><p>Apply tx to reference point offset to beams.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_all_profiles" title="HSTB.kluster.fqpr_generation.Fqpr.return_all_profiles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_all_profiles</span></code></a>()</p></td>
<td><p>convenience for xarray_conversion.BatchRead.return_all_profiles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_applicable_casts" title="HSTB.kluster.fqpr_generation.Fqpr.return_applicable_casts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_applicable_casts</span></code></a>([method])</p></td>
<td><p>When we check for sound velocity correct actions, we look to see if any new sv profiles imported into the fqpr instance are applicable, by running the chosen method (default is cast nearest in time to the ping chunk).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_dict" title="HSTB.kluster.fqpr_generation.Fqpr.return_cast_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_cast_dict</span></code></a>()</p></td>
<td><p>Return a dictionary object combining the profile data and the attribution for each cast</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance" title="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_cast_idx_nearestindistance</span></code></a>(idx_by_chunk)</p></td>
<td><p>Need to find the cast associated with each chunk of data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance_fourhours" title="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance_fourhours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_cast_idx_nearestindistance_fourhours</span></code></a>(...)</p></td>
<td><p>Need to find the cast associated with each chunk of data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime" title="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_cast_idx_nearestintime</span></code></a>(idx_by_chunk)</p></td>
<td><p>Need to find the cast associated with each chunk of data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime_fourhours" title="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime_fourhours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_cast_idx_nearestintime_fourhours</span></code></a>(...)</p></td>
<td><p>Need to find the cast associated with each chunk of data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_chunk_indices" title="HSTB.kluster.fqpr_generation.Fqpr.return_chunk_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_chunk_indices</span></code></a>(idx_mask, pings_per_chunk)</p></td>
<td><p>Use self.get_cluster_params to figure out how big the chunks should be according to the cluster memory capacity and pass that number in here as pings_per_chunk.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_line_dict" title="HSTB.kluster.fqpr_generation.Fqpr.return_line_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_line_dict</span></code></a>([line_names, ping_times])</p></td>
<td><p>Return all the lines with associated start and stop times for all sectors in the fqpr dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_line_time" title="HSTB.kluster.fqpr_generation.Fqpr.return_line_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_line_time</span></code></a>(line_name)</p></td>
<td><p>Return the start and end time for the given line name</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_line_xyzrph" title="HSTB.kluster.fqpr_generation.Fqpr.return_line_xyzrph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_line_xyzrph</span></code></a>(line_name)</p></td>
<td><p>Return only the relevant xyzrph (kluster vessel config data) entries for the given line name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_lines_for_times" title="HSTB.kluster.fqpr_generation.Fqpr.return_lines_for_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_lines_for_times</span></code></a>(times)</p></td>
<td><p>Given the 1d array of times (utc seconds), return a same size object array with the string value of the line file name that matches the time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_navigation" title="HSTB.kluster.fqpr_generation.Fqpr.return_navigation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_navigation</span></code></a>([start_time, end_time, ...])</p></td>
<td><p>Return the navigation from the multibeam data for the first sonar head.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_next_action" title="HSTB.kluster.fqpr_generation.Fqpr.return_next_action"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_next_action</span></code></a>([new_vertical_reference, ...])</p></td>
<td><p>Determine the next action to take, building the arguments for the fqpr_convenience.process_multibeam function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_next_unprocessed_line" title="HSTB.kluster.fqpr_generation.Fqpr.return_next_unprocessed_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_next_unprocessed_line</span></code></a>()</p></td>
<td><p>Return the next unprocessed line in this container, see line_is_processed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_processing_dashboard" title="HSTB.kluster.fqpr_generation.Fqpr.return_processing_dashboard"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_processing_dashboard</span></code></a>()</p></td>
<td><p>Return the necessary data for a dashboard like view of this fqpr instance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_rounded_frequency" title="HSTB.kluster.fqpr_generation.Fqpr.return_rounded_frequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_rounded_frequency</span></code></a>()</p></td>
<td><p>Returns the frequency rounded to match the freq settings commonly given with sonar manufacturer settings.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_soundings_in_polygon" title="HSTB.kluster.fqpr_generation.Fqpr.return_soundings_in_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_soundings_in_polygon</span></code></a>(polygon[, ...])</p></td>
<td><p>Using provided coordinates (in either horizontal_crs projected or geographic coordinates), return the soundings and sounding attributes for all soundings within the coordinates, see subset module.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_total_pings" title="HSTB.kluster.fqpr_generation.Fqpr.return_total_pings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_total_pings</span></code></a>([min_time, max_time])</p></td>
<td><p>Get the total ping count, optionally within the provided mintime maxtime range</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_total_soundings" title="HSTB.kluster.fqpr_generation.Fqpr.return_total_soundings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_total_soundings</span></code></a>([min_time, max_time])</p></td>
<td><p>Return the number of soundings in all systems within this fqpr instance, optionally within the provided mintime maxtime range</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.return_unique_mode" title="HSTB.kluster.fqpr_generation.Fqpr.return_unique_mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_unique_mode</span></code></a>()</p></td>
<td><p>Finds the unique mode entries in raw_ping Datasets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.run_filter" title="HSTB.kluster.fqpr_generation.Fqpr.run_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_filter</span></code></a>(filtername, *args[, ...])</p></td>
<td><p>Run the filter module with the provided filtername, will match the filename of the filter python file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.set_filter_by_polygon" title="HSTB.kluster.fqpr_generation.Fqpr.set_filter_by_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_filter_by_polygon</span></code></a>(polygon[, geographic])</p></td>
<td><p>Alternative way to set the ping_filter attribute which can be used with set_variable_by_filter get_variable_by_filter, see subset module.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.set_variable_by_filter" title="HSTB.kluster.fqpr_generation.Fqpr.set_variable_by_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_variable_by_filter</span></code></a>([var_name, newval, ...])</p></td>
<td><p>ping_filter is set upon selecting points in 2d/3d in Kluster.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.set_vertical_reference" title="HSTB.kluster.fqpr_generation.Fqpr.set_vertical_reference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_vertical_reference</span></code></a>(vert_ref)</p></td>
<td><p>Set the Fqpr instance vertical reference.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_lines" title="HSTB.kluster.fqpr_generation.Fqpr.subset_by_lines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subset_by_lines</span></code></a>(line_names)</p></td>
<td><p>Use subset module to trim the fqpr instance to the given lines</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_time" title="HSTB.kluster.fqpr_generation.Fqpr.subset_by_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subset_by_time</span></code></a>([mintime, maxtime])</p></td>
<td><p>Use subset module to trim the fqpr instance to the given time range</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_time_and_beam" title="HSTB.kluster.fqpr_generation.Fqpr.subset_by_time_and_beam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subset_by_time_and_beam</span></code></a>(subset_time, subset_beam)</p></td>
<td><p>Use subset module to subset by time,beam provided, returns a 1d boolean mask for each sonar head</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_times" title="HSTB.kluster.fqpr_generation.Fqpr.subset_by_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subset_by_times</span></code></a>(time_segments)</p></td>
<td><p>Use subset module to trim the fqpr instance to the given time ranges</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_variables" title="HSTB.kluster.fqpr_generation.Fqpr.subset_variables"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subset_variables</span></code></a>(variable_selection[, ...])</p></td>
<td><p>Take specific variable names and return just those variables in a new xarray dataset, see subset module.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_variables_by_line" title="HSTB.kluster.fqpr_generation.Fqpr.subset_variables_by_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subset_variables_by_line</span></code></a>(variable_selection)</p></td>
<td><p>Apply subset_variables to get the data split up into lines for the variable_selection provided, see subset module</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.sv_correct" title="HSTB.kluster.fqpr_generation.Fqpr.sv_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sv_correct</span></code></a>([add_cast_files, ...])</p></td>
<td><p>Apply sv cast/surface sound speed to raytrace.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.write_attribute_to_ping_records" title="HSTB.kluster.fqpr_generation.Fqpr.write_attribute_to_ping_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_attribute_to_ping_records</span></code></a>(attr_dict)</p></td>
<td><p>Convenience method that allows you to write the provided attribute dictionary to each ping dataset and change the currently loaded instance as well</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr.write_intermediate_futs_to_zarr" title="HSTB.kluster.fqpr_generation.Fqpr.write_intermediate_futs_to_zarr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_intermediate_futs_to_zarr</span></code></a>(mode, ...[, ...])</p></td>
<td><p>Flush some of the intermediate data that was mapped to the cluster (and lives in futures objects) to disk, puts it in the multibeam, as the time dimension should be the same.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes Documentation</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.has_sbet">
<span class="sig-name descname"><span class="pre">has_sbet</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.has_sbet" title="Permalink to this definition">¶</a></dt>
<dd><p>True if an SBET has been imported into this FQPR instance</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If SBET has been imported, return True</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.input_datum">
<span class="sig-name descname"><span class="pre">input_datum</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.input_datum" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic input datum of the converted multibeam data.  Will be ignored in processing if an sbet_datum exists,
as sbet navigation and altitude are used by default if they exist unless you explicitly request non-sbet processing.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.last_operation_date">
<span class="sig-name descname"><span class="pre">last_operation_date</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.last_operation_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the datetime of the last operation performed on this fqpr instance</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>datetime object of the last operation performed on this fqpr instance</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>datetime</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.max_time">
<span class="sig-name descname"><span class="pre">max_time</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.max_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nicely formatted time in UTC for the end time of this fqpr object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the formatted string representation of the maximum time of this dataset in UTC</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.min_time">
<span class="sig-name descname"><span class="pre">min_time</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.min_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nicely formatted time in UTC for the start time of this fqpr object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the formatted string representation of the minimum time of this dataset in UTC</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.number_of_heads">
<span class="sig-name descname"><span class="pre">number_of_heads</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.number_of_heads" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of sonar heads for the sonar in this FQPR instance</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of sonar heads</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.number_of_pings">
<span class="sig-name descname"><span class="pre">number_of_pings</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.number_of_pings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of pings for the sonar in this FQPR instance</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of sonar heads</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.sbet_navigation">
<span class="sig-name descname"><span class="pre">sbet_navigation</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.sbet_navigation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sbet navigation for the first sonar head.  Can assume that all sonar heads have basically the same navigation</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.sonar_model">
<span class="sig-name descname"><span class="pre">sonar_model</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.sonar_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sonar type from the ping record</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the sonar model string</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.status">
<span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.status" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the processing status of the Fqpr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the processing status of the Fqpr object</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods Documentation</p>
<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.calc_max_var">
<span class="sig-name descname"><span class="pre">calc_max_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'depthoffset'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.calc_max_var" title="Permalink to this definition">¶</a></dt>
<dd><p>For given variable, return the maximum value found across all sectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>varname</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the variable you are interested in</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>maximum value across all sectors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.calc_min_var">
<span class="sig-name descname"><span class="pre">calc_min_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'depthoffset'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.calc_min_var" title="Permalink to this definition">¶</a></dt>
<dd><p>For given variable, return the minimum value found across all sectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>varname</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the variable you are interested in</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>minimum value across all sectors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.calculate_total_uncertainty">
<span class="sig-name descname"><span class="pre">calculate_total_uncertainty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.calculate_total_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the tpu module to calculate total horizontal uncertainty and total vertical uncertainty for each sounding.
See tpu.py for more information</p>
<div class="line-block">
<div class="line">To process only a section of the dataset, use subset_time.</div>
<div class="line">ex: subset_time=[1531317999, 1531321000] means only process times that are from 1531317999 to 1531321000</div>
<div class="line">ex: subset_time=[[1531317999, 1531318885], [1531318886, 1531321000]] means only process times that are
from either 1531317999 to 1531318885 or 1531318886 to 1531321000</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subset_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – List of unix timestamps in seconds, used as ranges for times that you want to process.</p></li>
<li><p><strong>dump_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True dump the futures to the multibeam datastore.  Set this to false for an entirely in memory
workflow</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">close_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Must forcibly close the logging handlers to allow the data written to disk to be moved or deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.construct_crs">
<span class="sig-name descname"><span class="pre">construct_crs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WGS84'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.construct_crs" title="Permalink to this definition">¶</a></dt>
<dd><p>Build pyproj crs from several different options, used with georef_across_along_depth.</p>
<p>Optionally set the vertical reference as well, using set_vertical_reference.  This isn’t tied to the pyproj
instance, so it can be done separately.</p>
<p>Options include:
- epsg mode: set epsg to string identifier
- geographic mode: set ellips to string identifier and projected to False
- projected mode: set ellips to sting identifier and projected to True.  Will autodetermine zone</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epsg</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – optional, epsg code</p></li>
<li><p><strong>datum</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – datum identifier i.e. ‘WGS84’ or ‘NAD83’</p></li>
<li><p><strong>projected</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True uses utm zone projected coordinates</p></li>
<li><p><strong>vert_ref</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – vertical reference for the survey, one of [‘ellipse’, ‘waterline’, ‘NOAA MLLW’, ‘NOAA MHW’, ‘Aviso MLLW’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If true, the CRS was successfully constructed and was different from the original</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this Fqpr instance.  The xarray datasets will be distinct, so you can subset them without
affecting this instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>copy of the current Fqpr object</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#HSTB.kluster.fqpr_generation.Fqpr" title="HSTB.kluster.fqpr_generation.Fqpr">Fqpr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.determine_altitude_corr">
<span class="sig-name descname"><span class="pre">determine_altitude_corr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_att</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tx_tstmp_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestmp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.determine_altitude_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>We use the nav as provided by the POSMV.  This will be at the reference point designated by the POSMV.  As we
assume that your RP is either the TX or the IMU, if there is a lever arm between TX and RP, there is induced
heave in the altitude equal to the attitude-rotated TX lever arm.</p>
<p>Generate that time series attitude adjustment and add it to the altitude record.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DataArray</span></code>) – altitude at ping time</p></li>
<li><p><strong>raw_att</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>) – raw attitude Dataset including roll, pitch, yaw</p></li>
<li><p><strong>tx_tstmp_idx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DataArray</span></code>) – ping time index</p></li>
<li><p><strong>prefixes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – prefix identifier for the tx/rx, will vary for dual head systems</p></li>
<li><p><strong>timestmp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – timestamp for the appropriate xyzrph record</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>navigation at ping time (latitude, longitude, altitude) with altitude correction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.determine_induced_heave">
<span class="sig-name descname"><span class="pre">determine_induced_heave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hve</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_att</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tx_tstmp_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestmp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.determine_induced_heave" title="Permalink to this definition">¶</a></dt>
<dd><p>From Kongsberg datagram doc:
Note that heave is displayed and logged as positive downwards (the sign is changed) including roll and pitch
induced lever arm translation to the system’s transmit transducer.</p>
<p>Here we use the primary to secondary lever arm to build induced heave seen at the secondary system.  As heave
is reported at the tx of the primary system.  This will return all zeros for induced heave in instances where:</p>
<ul class="simple">
<li><p>system is not a dual head system</p></li>
<li><p>system is the primary system of a dual head system</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>) – raw_ping dataset for this sector/freq/serial number</p></li>
<li><p><strong>hve</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DataArray</span></code>) – heave record at ping time</p></li>
<li><p><strong>raw_att</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>) – raw attitude Dataset including roll, pitch, yaw</p></li>
<li><p><strong>tx_tstmp_idx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DataArray</span></code>) – ping time index</p></li>
<li><p><strong>prefixes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – prefix identifier for the tx/rx, will vary for dual head systems</p></li>
<li><p><strong>timestmp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – timestamp for the appropriate xyzrph record</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>induced heave (z) value for each ping time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>xr.DataArray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.export_dataset">
<span class="sig-name descname"><span class="pre">export_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.export_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the export module to export each variable in the given dataset to one csv, writing to the provided path, see export.export_dataset_to_csv</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.export_lines_to_file">
<span class="sig-name descname"><span class="pre">export_lines_to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linenames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csv'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csv_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_detection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_pos_down</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">export_by_identifiers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.export_lines_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the export module to export only the data belonging to the given lines to file, see export.export_lines_to_file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.export_pings_to_file">
<span class="sig-name descname"><span class="pre">export_pings_to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csv'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csv_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_detection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_pos_down</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">export_by_identifiers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.export_pings_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the export module to export point cloud relevant data to file, see export.export_pings_to_file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.export_soundings_to_file">
<span class="sig-name descname"><span class="pre">export_soundings_to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datablock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csv'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csv_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_detection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_pos_down</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.export_soundings_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the export module to export given soundings to file, see export.export_soundings_to_file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.export_tracklines_to_file">
<span class="sig-name descname"><span class="pre">export_tracklines_to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linenames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GPKG'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.export_tracklines_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the export module to export the navigation to vector file, see export.export_tracklines_to_file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.export_variable">
<span class="sig-name descname"><span class="pre">export_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_centered</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.export_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the export module to export the given variable to csv, writing to the provided path, see export.export_variable_to_csv</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.generate_starter_orientation_vectors">
<span class="sig-name descname"><span class="pre">generate_starter_orientation_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">txrx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tstmp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.generate_starter_orientation_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Take in identifiers to find the correct xyzrph entry, and use the heading value to figure out if the
transmitter/receiver (tx/rx) is oriented backwards.  Otherwise return ideal vectors for representation of
the tx/rx.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>txrx</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – transmit/receive identifiers for xyzrph dict ([‘tx’, ‘rx’])</p></li>
<li><p><strong>tstmp</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – timestamp for the appropriate xyzrph entry</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.georef_xyz">
<span class="sig-name descname"><span class="pre">georef_xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefer_pp_nav</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vdatum_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.georef_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the raw attitude/navigation to transform the vessel relative along/across/down offsets to georeferenced
soundings.  Will support transformation to geographic and projected coordinate systems and with a vertical
reference that you select.</p>
<p>If uncertainty is included in the source data, will calculate the unc based on depth.</p>
<p>First does a forward transformation using the geoid provided in horizontal_crs
Then does a transformation from geographic to projected, if that is included in horizontal_crs</p>
<p>Uses pyproj to do all transformations.  User must run self.construct_crs first to establish the destination
datum and ellipsoid.</p>
<p>Sends the data and calculations to the cluster, receive futures objects back.  Use the dump_data/delete_futs to
interact with the futures object.</p>
<div class="line-block">
<div class="line">To process only a section of the dataset, use subset_time.</div>
<div class="line">ex: subset_time=[1531317999, 1531321000] means only process times that are from 1531317999 to 1531321000</div>
<div class="line">ex: subset_time=[[1531317999, 1531318885], [1531318886, 1531321000]] means only process times that are
from either 1531317999 to 1531318885 or 1531318886 to 1531321000</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subset_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – List of unix timestamps in seconds, used as ranges for times that you want to process.</p></li>
<li><p><strong>prefer_pp_nav</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True will use post-processed navigation/height (SBET)</p></li>
<li><p><strong>dump_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True dump the futures to the multibeam datastore.  Set this to false for an entirely in memory
workflow</p></li>
<li><p><strong>vdatum_directory</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – if ‘NOAA MLLW’ ‘NOAA MHW’ is the vertical reference, a path to the vdatum directory is required here</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.get_beam_pointing_vectors">
<span class="sig-name descname"><span class="pre">get_beam_pointing_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.get_beam_pointing_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam pointing vector is the beam specific vector that arises from the intersection of the tx ping and rx cone
of sensitivity.  Points at that area.  Is in the geographic coordinate system, built using the tx/rx at time of
ping/receive.  Sends the data and calculations to the cluster, receive futures objects back.
Use the dump_data/delete_futs to interact with the futures object.</p>
<div class="line-block">
<div class="line">To process only a section of the dataset, use subset_time.</div>
<div class="line">ex: subset_time=[1531317999, 1531321000] means only process times that are from 1531317999 to 1531321000</div>
<div class="line">ex: subset_time=[[1531317999, 1531318885], [1531318886, 1531321000]] means only process times that are
from either 1531317999 to 1531318885 or 1531318886 to 1531321000</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subset_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – List of unix timestamps in seconds, used as ranges for times that you want to process.</p></li>
<li><p><strong>dump_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True dump the futures to the multibeam datastore.  Set this to false for an entirely in memory
workflow</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.get_cluster_params">
<span class="sig-name descname"><span class="pre">get_cluster_params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.get_cluster_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to figure out what the chunk size and number of chunks at a time parameters should be given the dims
of the dataset.  It’s pretty rough, definitely needs something more sophisticated, but this serves as a place
holder.</p>
<p>Basically uses the avg number of beams per ping and the worker memory size to get the chunk sizes (in time)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>int</em> – number of pings in each chunk</p></li>
<li><p><em>int</em> – number of chunks to run at once</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.get_orientation_vectors">
<span class="sig-name descname"><span class="pre">get_orientation_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_interp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.get_orientation_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Using attitude angles, mounting angles, build the tx/rx vectors that represent the orientation of the tx/rx at
time of transmit/receive.   Sends the data and calculations to the cluster, receive futures objects back.
Use the dump_data/delete_futs to interact with the futures object.</p>
<div class="line-block">
<div class="line">To process only a section of the dataset, use subset_time.</div>
<div class="line">ex: subset_time=[1531317999, 1531321000] means only process times that are from 1531317999 to 1531321000</div>
<div class="line">ex: subset_time=[[1531317999, 1531318885], [1531318886, 1531321000]] means only process times that are
from either 1531317999 to 1531318885 or 1531318886 to 1531321000</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subset_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – List of unix timestamps in seconds, used as ranges for times that you want to process.</p></li>
<li><p><strong>dump_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True dump the tx/rx vectors to the multibeam datastore.  Set this to false for an entirely in memory
workflow</p></li>
<li><p><strong>initial_interp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will interpolate attitude to the ping record and store in the raw_ping datasets.  This
is not mandatory for processing, but useful for other kluster functions post processing.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.get_variable_by_filter">
<span class="sig-name descname"><span class="pre">get_variable_by_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selected_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_sonar_head</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.get_variable_by_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>ping_filter is set upon selecting points in 2d/3d in Kluster.  See return_soundings_in_polygon.  Here we can take
those points and get one of the variables individually.  This is going to be faster than running return_soundings_in_polygon
again and is kind of an added feature for just getting one other variable.</p>
<p>Optionally, you can include a selected_index that is a list of flattened indices to points in the ping_filter
that you want to super-select, see subset module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.import_post_processed_navigation">
<span class="sig-name descname"><span class="pre">import_post_processed_navigation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">navfiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errorfiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekstart_year</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekstart_week</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_datum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_zone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_ellipsoid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_gap_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.import_post_processed_navigation" title="Permalink to this definition">¶</a></dt>
<dd><p>Load from post processed navigation files (currently just SBET and SMRMSG) to get lat/lon/altitude as well
as 3d error for further processing.  Will save as variables/attributes within the ping record for the nearest
data point to each ping time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>navfiles</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of postprocessed navigation file paths</p></li>
<li><p><strong>errorfiles</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – list of postprocessed error file paths.  If provided, must be same number as nav files</p></li>
<li><p><strong>logfiles</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – list of export log file paths associated with navfiles.  If provided, must be same number as nav files</p></li>
<li><p><strong>weekstart_year</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – if you aren’t providing a logfile, must provide the year of the sbet here</p></li>
<li><p><strong>weekstart_week</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – if you aren’t providing a logfile, must provide the week of the sbet here</p></li>
<li><p><strong>override_datum</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – provide a string datum identifier if you want to override what is read from the log or you don’t have a
log, ex: ‘NAD83 (2011)’</p></li>
<li><p><strong>override_grid</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – provide a string grid identifier if you want to override what is read from the log or you don’t have a log,
ex: ‘Universal Transverse Mercator’</p></li>
<li><p><strong>override_zone</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – <dl class="simple">
<dt>provide a string zone identifier if you want to override what is read from the log or you don’t have a log,</dt><dd><p>ex: ‘UTM North 20 (66W to 60W)’</p>
</dd>
</dl>
</p></li>
<li><p><strong>override_ellipsoid</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – provide a string ellipsoid identifier if you want to override what is read from the log or you don’t have a
log, ex: ‘GRS80’</p></li>
<li><p><strong>max_gap_length</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – maximum allowable gap in the sbet in seconds, excluding gaps found in raw navigation</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will include files that are already in the navigation dataset as valid</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.import_sound_velocity_files">
<span class="sig-name descname"><span class="pre">import_sound_velocity_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_selection_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest_in_time'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.import_sound_velocity_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Load to self.cast_files the file paths to the sv casts of interest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – either a list of files to include or the path to a directory containing sv files (only supporting .svp currently)</p></li>
<li><p><strong>cast_selection_method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – method used to determine the cast appropriate for each data chunk.  Used here to determine whether or not this new cast(s)
will require reprocessing, i.e. they are selected by one or more chunks of this dataset.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.initial_att_interpolation">
<span class="sig-name descname"><span class="pre">initial_att_interpolation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.initial_att_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>We provide as an optional step in self.get_orientation_vectors (or run separately) the ability to interpolate
the raw attitude and navigation to the ping record times and save these records to disk.  Otherwise,
each time attitude/navigation is needed by the processing module, it will be interpolated then.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.initialize_intermediate_data">
<span class="sig-name descname"><span class="pre">initialize_intermediate_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sec_ident</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ky</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.initialize_intermediate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>self.intermediate_dat is the storage for all the futures generated by the main processes
(get_orientation_vectors, get_beam_pointing_vectors, etc.).  It is organized by sector identifier/process key.</p>
<p>This method will initialize the storage for a new sector identifier/process key.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sec_ident</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – raw_ping sector identifier, ex: ‘40107_1_320000’</p></li>
<li><p><strong>ky</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – process key, one of ‘orientation’, ‘bpv’, etc.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.initialize_log">
<span class="sig-name descname"><span class="pre">initialize_log</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.initialize_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the fqpr logger using the multibeam logfile attribute.</p>
<div class="line-block">
<div class="line">self.logfile is the path to the text log that the logging module uses</div>
<div class="line">self.logger is the logging.Logger object</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.interp_to_ping_record">
<span class="sig-name descname"><span class="pre">interp_to_ping_record</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.interp_to_ping_record" title="Permalink to this definition">¶</a></dt>
<dd><p>Take in a dataset that is not at ping time (raw navigation, attitude, etc.) and interpolate it to ping time
and save it to the raw ping datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sources</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – one or more datasets that you want to interpolate and save to the raw ping datastores</p></li>
<li><p><strong>attributes</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>]) – optional attributes to write to the zarr datastore</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.intersects">
<span class="sig-name descname"><span class="pre">intersects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geographic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the provided extents intersect with this fqpr instance.  Requires georeferencing has been performed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – minimum northing/latitude of extents</p></li>
<li><p><strong>max_y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – maximum northing/latitude of extents</p></li>
<li><p><strong>min_x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – minimum easting/longitude of extents</p></li>
<li><p><strong>max_x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – maximum easting/longitude of extents</p></li>
<li><p><strong>geographic</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, autotransforms to projected, if False, uses the northing/easting</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the extents provided intersect with the fqpr instance, False if they do not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.is_processed">
<span class="sig-name descname"><span class="pre">is_processed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.is_processed" title="Permalink to this definition">¶</a></dt>
<dd><p>Kluster maintains two records for processing status.  current_processing_status is a scalar attribute used by
the intelligence engine to max processing decisions.  processing_status is a sounding variable that records the
integer processing status for each sounding.</p>
<p>The is_processed check will see if this fqpr instance has achieved max_processing_status.  in_depth will use
the processing_status variable, checking each sounding attribute to compare against the max_processing_status.
Otherwise, we just check the current_processing_status number, which is much faster</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>in_depth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will use the more expensive check to ensure each sounding is fully processed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>if True, this fqpr is fully processed</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.line_attributes">
<span class="sig-name descname"><span class="pre">line_attributes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.line_attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Attributes by line are added after conversion to the ping attribution.  This is a shortcut for returning the attribution
for a line</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the line file, ex: 0634_20180711_142125.all</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of line attributes, [start time, end time, start latitude, start longitude, end latitude, end longitude,
line azimuth]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.line_is_processed">
<span class="sig-name descname"><span class="pre">line_is_processed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.line_is_processed" title="Permalink to this definition">¶</a></dt>
<dd><p>If line is processed, the TVU will not be all NaN in the middle of the line.  This method will check that and
return whether or the given line is processed.  We use TVU because</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the line you want to check, ex: ‘0648_20180711_151142.all’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None if line is not found, False if line is not processed, True if line is processed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.overwrite_raw_navigation">
<span class="sig-name descname"><span class="pre">overwrite_raw_navigation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">navfiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekstart_year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weekstart_week</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.overwrite_raw_navigation" title="Permalink to this definition">¶</a></dt>
<dd><p>Load from raw navigation files (currently just POS MV .000) to get lat/lon/altitude.  Will overwrite the original
raw navigation zarr rootgroup, so you can compare pos mv to sbet.</p>
<p>No interpolation is done, but it will slice the incoming data to the time extents of the raw navigation and
identify time gaps larger than the provided max_gap_length in seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>navfiles</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of postprocessed navigation file paths</p></li>
<li><p><strong>weekstart_year</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – must provide the year of the pos mv file here</p></li>
<li><p><strong>weekstart_week</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – must provide the week of the pos mv file here</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will include files that are already in the navigation dataset as valid</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.read_from_source">
<span class="sig-name descname"><span class="pre">read_from_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">build_offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.read_from_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate rawdat object’s appropriate read class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>build_offsets</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if this is set, also build the xyzrph attribute, which is mandatory for processing later in Kluster.  Make
it optional so that when processing chunks of files, we can just run it once at the end after read()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.remove_post_processed_navigation">
<span class="sig-name descname"><span class="pre">remove_post_processed_navigation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.remove_post_processed_navigation" title="Permalink to this definition">¶</a></dt>
<dd><p>import_post_processed_navigation will write navigation and navigation related attributes to the Fqpr instance.
This method will remove all variables and attributes related to post processed navigation.  If the current processing
status of this Fqpr is greater than or equal to georeference, this method will also write a new current processing status
informing the user/intelligence module to restart processing at georeferencing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.remove_profile">
<span class="sig-name descname"><span class="pre">remove_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.remove_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Sound velocity profiles are stored in the Fqpr datastore as attributes with the ‘profile_timestamp’ format, ex:
‘profile_1503411780’.  Here we take a profile name that is of that format, and remove the matching profile from the
Fqpr attribution, both the loaded data and the data written to disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>profile_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the profile with the ‘profile_timestamp’ format, ex: ‘profile_1503411780’</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.restore_subset">
<span class="sig-name descname"><span class="pre">restore_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.restore_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores the original data if subset_by_time has been run.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_additional_xyz_offsets">
<span class="sig-name descname"><span class="pre">return_additional_xyz_offsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestmp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_by_chunk</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_additional_xyz_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply tx to reference point offset to beams.</p>
<p>All the kongsberg sonars have additional offsets in the installation parameters document listed as the difference
between the measured center of the transducer and the phase center of the transducer.  Here we get those values
for the provided system (we’ve previously stored them in the xyzrph data)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>) – xarray dataset for the rawping dataset we are working with</p></li>
<li><p><strong>prefixes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – prefix identifier for the tx/rx, will vary for dual head systems</p></li>
<li><p><strong>timestmp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – timestamp for the appropriate xyzrph record</p></li>
<li><p><strong>idx_by_chunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of xarray Datarrays, values are the integer indexes of the pings to use, coords are the time of ping</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[float, additional x offset, float, additional y offset, float, additional z offset]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_all_profiles">
<span class="sig-name descname"><span class="pre">return_all_profiles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_all_profiles" title="Permalink to this definition">¶</a></dt>
<dd><p>convenience for xarray_conversion.BatchRead.return_all_profiles</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_applicable_casts">
<span class="sig-name descname"><span class="pre">return_applicable_casts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest_in_time'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_applicable_casts" title="Permalink to this definition">¶</a></dt>
<dd><p>When we check for sound velocity correct actions, we look to see if any new sv profiles imported into the
fqpr instance are applicable, by running the chosen method (default is cast nearest in time to the ping chunk).
If new profiles are applicable, we need to re-sv correct.  Use this method to find the applicable sound velocity
casts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> – string identifier for the cast selection method, default is nearest in time to the ping chunk</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of profile names for all casts that would be used if we sound velocity correct using the provided
method</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_cast_dict">
<span class="sig-name descname"><span class="pre">return_cast_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary object combining the profile data and the attribution for each cast</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of all the data for each profile, key is profile attribute name, ex: ‘profile_1495563079’</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance">
<span class="sig-name descname"><span class="pre">return_cast_idx_nearestindistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_by_chunk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to find the cast associated with each chunk of data.  Currently we just take the average chunk time and
find the closest cast in terms of distance.  We also need the index of the chunk in the original size
dataset, as we built the casts based on the original size soundvelocity dataarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx_by_chunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of xarray Datarrays, values are the integer indexes of the pings to use, coords are the time of ping</p></li>
<li><p><strong>silent</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will not print out messages</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of lists, each sub-list is [xarray Datarray with times/indices for the chunk, integer index of the cast that
applies to that chunk]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance_fourhours">
<span class="sig-name descname"><span class="pre">return_cast_idx_nearestindistance_fourhours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_by_chunk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestindistance_fourhours" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to find the cast associated with each chunk of data.  Currently we just take the average chunk time and
find the closest cast in terms of distance.  We also need the index of the chunk in the original size
dataset, as we built the casts based on the original size soundvelocity dataarray.</p>
<p>Only retain the cast if it is within four hours.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx_by_chunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of xarray Datarrays, values are the integer indexes of the pings to use, coords are the time of ping</p></li>
<li><p><strong>silent</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will not print out messages</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of lists, each sub-list is [xarray Datarray with times/indices for the chunk, integer index of the cast that
applies to that chunk]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime">
<span class="sig-name descname"><span class="pre">return_cast_idx_nearestintime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_by_chunk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to find the cast associated with each chunk of data.  Currently we just take the average chunk time and
find the closest cast time, and assign that cast.  We also need the index of the chunk in the original size
dataset, as we built the casts based on the original size soundvelocity dataarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx_by_chunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of xarray Datarrays, values are the integer indexes of the pings to use, coords are the time of ping</p></li>
<li><p><strong>silent</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will not print out messages</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of lists, each sub-list is [xarray Datarray with times/indices for the chunk, integer index of the cast that
applies to that chunk]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime_fourhours">
<span class="sig-name descname"><span class="pre">return_cast_idx_nearestintime_fourhours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_by_chunk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_cast_idx_nearestintime_fourhours" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to find the cast associated with each chunk of data.  Currently we just take the average chunk time and
find the closest cast time, and assign that cast.  We also need the index of the chunk in the original size
dataset, as we built the casts based on the original size soundvelocity dataarray.</p>
<p>This method will only retain the cast if it is within four hours, otherwise, you will get a None for that chunk</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx_by_chunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of xarray Datarrays, values are the integer indexes of the pings to use, coords are the time of ping</p></li>
<li><p><strong>silent</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will not print out messages</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of lists, each sub-list is [xarray Datarray with times/indices for the chunk, integer index of the cast that
applies to that chunk]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_chunk_indices">
<span class="sig-name descname"><span class="pre">return_chunk_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pings_per_chunk</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_chunk_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Use self.get_cluster_params to figure out how big the chunks should be according to the cluster memory capacity
and pass that number in here as pings_per_chunk.  Use pings_per_chunk to divide the idx (boolean mask of
applicable pings with time of ping as a coordinate)</p>
<p>Idx_of_chunk values are dependent on the mask.  The total lengths will be equivalent, with the values counting
from zero to length of mask.  This lets us use it to index the data later on.  Idx_of_chunk time is the ping
time associated with the data we are going to be pulling later.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx_mask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">DataArray</span></code>) – the applicable_index generated from return_system_time_indexed_array</p></li>
<li><p><strong>pings_per_chunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – number of pings in each worker chunk</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of xarray Datarrays, values are the integer indexes of the pings to use, coords are the time of ping</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_line_dict">
<span class="sig-name descname"><span class="pre">return_line_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ping_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_line_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the lines with associated start and stop times for all sectors in the fqpr dataset.</p>
<p>If line_names is provide, only return line data for those lines.  If ping_times is provided, trim all lines
or drop lines that are not within the ping_times tuple (starttime in utc seconds, endtime in utc seconds)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line_names</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – if provided, only returns data for the line(s), otherwise, returns data for all lines</p></li>
<li><p><strong>ping_times</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>]) – time to select the dataset by, must be a tuple of (min time, max time) in utc seconds.  If None, will use
the full min/max time of the dataset</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary of names/start and stop times for all lines, ex: {‘0022_20190716_232128_S250.all’:
[1563319288.304, 1563319774.876]}</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_line_time">
<span class="sig-name descname"><span class="pre">return_line_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_line_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start and end time for the given line name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – file name for the multibeam file, ex: 0000_testhis.all</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – start time in utc seconds for the line</p></li>
<li><p><em>float</em> – end time in utc seconds for the line</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_line_xyzrph">
<span class="sig-name descname"><span class="pre">return_line_xyzrph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_line_xyzrph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return only the relevant xyzrph (kluster vessel config data) entries for the given line name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – file name of the multibeam line</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>xyzrph trimmed to only the relevant entries for the line</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_lines_for_times">
<span class="sig-name descname"><span class="pre">return_lines_for_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_lines_for_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the 1d array of times (utc seconds), return a same size object array with the string value of the line
file name that matches the time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>times</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code>) – 1d numpy array of times in utc seconds</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1d object array of the string file name for the multibeam file that encompasses each time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_navigation">
<span class="sig-name descname"><span class="pre">return_navigation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nav_source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_navigation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the navigation from the multibeam data for the first sonar head. Can assume that all sonar heads have
basically the same navigation.  If sbet navigation exists, return that instead, renaming the sbet variables
so that existing methods work.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – if provided will allow you to only return navigation after this time.  Selects the nearest time value to
the one provided.</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – if provided will allow you to only return navigation before this time.  Selects the nearest time value to
the one provided.</p></li>
<li><p><strong>nav_source</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – one of [‘raw’, ‘processed’] if you want to specify the navigation source to be the raw
multibeam data or the processed sbet</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>latitude/longitude/altitude pulled from the navigation part of the ping record</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_next_action">
<span class="sig-name descname"><span class="pre">return_next_action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_vertical_reference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_coordinate_system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_angles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_tpu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_input_datum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_waterline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'normal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_selection_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest_in_time'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_next_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the next action to take, building the arguments for the fqpr_convenience.process_multibeam function.
Uses the processing status, which is updated as a process is completed at a sounding level.</p>
<p>0 = conversion
1 = orientation
2 = beam vectors
3 = sound velocity
4 = georeference
5 = tpu</p>
<p>Used in fqpr_intelligence in generating processing actions to take as data is converted/updated.</p>
<p>Needs some more sophistication with time ranges (i.e. navigation was added, but only for xxxxxx.xx-xxxxxxxx.xx
time range, only process this segment)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_vertical_reference</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – If the user sets a new vertical reference that does not match the existing one, this will trigger a processing
action starting at georeferencing</p></li>
<li><p><strong>new_coordinate_system</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">CRS</span></code>]) – If the user sets a new coordinate system that does not match the existing one, this will trigger a
processing action starting at georeferencing</p></li>
<li><p><strong>new_offsets</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True if new offsets have been set, requires processing starting at sound velocity correction</p></li>
<li><p><strong>new_angles</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True if new mounting angles have been set, requires the full processing stack to be run</p></li>
<li><p><strong>new_tpu</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True if new tpu values have been set, requires compute TPU to run</p></li>
<li><p><strong>new_input_datum</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – None, if there is no change to the input datum requested, otherwise this is the new input datum we need to set,
should trigger a new processing action starting at georeferencing</p></li>
<li><p><strong>new_waterline</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True if a new waterline value has been set, requires processing starting at sound velocity correction</p></li>
<li><p><strong>process_mode</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – one of the following process modes:
- normal = generate the next processing action using the current_processing_status attribute as normal
- reprocess = perform a full reprocess of the dataset ignoring the current_processing_status
- convert_only = only convert incoming data, return no processing actions
- concatenate = process line by line if there is no processed data for that line</p></li>
<li><p><strong>cast_selection_method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – the method used to select the cast that goes with each chunk of the dataset, one of [‘nearest_in_time’,
‘nearest_in_time_four_hours’, ‘nearest_in_distance’, ‘nearest_in_distance_four_hours’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>list</em> – list of processing arguments to feed fqpr_convenience.process_multibeam</p></li>
<li><p><em>dict</em> – dict of processing keyword arguments to feed fqpr_convenience.process_multibeam</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_next_unprocessed_line">
<span class="sig-name descname"><span class="pre">return_next_unprocessed_line</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_next_unprocessed_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next unprocessed line in this container, see line_is_processed</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>line name for the next unprocessed line</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_processing_dashboard">
<span class="sig-name descname"><span class="pre">return_processing_dashboard</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_processing_dashboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the necessary data for a dashboard like view of this fqpr instance.  Currently we are concerned with
the total multibeam files associated with instance, and the processing status of each sector at a sounding level.</p>
<div class="line-block">
<div class="line">The returned dict object looks something like this:</div>
<div class="line"><br /></div>
<div class="line">{‘sounding_status’: {‘40072_0_260000’: {‘converted’: 0, ‘orientation’: 0, ‘beamvector’: 0, ‘soundvelocity’: 0,</div>
<div class="line-block">
<div class="line-block">
<div class="line-block">
<div class="line">‘georeference’: 0, ‘tpu’: 7536046},</div>
</div>
<div class="line">‘40072_0_290000’: {‘converted’: 0, ‘orientation’: 0, ‘beamvector’: 0, ‘soundvelocity’: 0,</div>
<div class="line-block">
<div class="line">‘georeference’: 0, ‘tpu’: 7536046}, …</div>
</div>
</div>
<div class="line">‘last_run’: {‘40072_0_260000’: {‘_conversion_complete’: ‘Tue Nov 24 12:42:41 2020’, ‘_compute_orientation_complete’: ‘Tue Nov 24 12:44:21 2020’,</div>
<div class="line-block">
<div class="line-block">
<div class="line">‘_compute_beam_vectors_complete’: ‘Tue Nov 24 12:46:20 2020’, ‘_sound_velocity_correct_complete’: ‘Tue Nov 24 12:48:25 2020’,</div>
<div class="line">‘_georeference_soundings_complete’: ‘Tue Nov 24 12:50:04 2020’, ‘_total_uncertainty_complete’: ‘Tue Nov 24 12:51:55 2020’},</div>
</div>
<div class="line">‘40072_0_290000’: {‘_conversion_complete’: ‘Tue Nov 24 12:42:41 2020’, ‘_compute_orientation_complete’: ‘Tue Nov 24 12:44:40 2020’,</div>
<div class="line-block">
<div class="line">‘_compute_beam_vectors_complete’: ‘Tue Nov 24 12:46:40 2020’, ‘_sound_velocity_correct_complete’: ‘Tue Nov 24 12:48:39 2020’,</div>
<div class="line">‘_georeference_soundings_complete’: ‘Tue Nov 24 12:50:21 2020’, ‘_total_uncertainty_complete’: ‘Tue Nov 24 12:52:14 2020’}, …</div>
</div>
</div>
<div class="line">‘multibeam_files’: {‘0000_202003_S222_EM2040.all’: [1584426535.491, 1584426638.015], ‘0001_202003_S222_EM2040.all’: [1584427154.74, 1584427341.396],</div>
<div class="line-block">
<div class="line">‘0002_202003_S222_EM2040.all’: [1584427786.983, 1584427894.186], ‘0003_202003_S222_EM2040.all’: [1584428272.65, 1584428465.862], …</div>
</div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>processing status at the sector level</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_rounded_frequency">
<span class="sig-name descname"><span class="pre">return_rounded_frequency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_rounded_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the frequency rounded to match the freq settings commonly given with sonar manufacturer settings.  If
you have entries like [270000, 290000, 310000, 330000], it returns [300000].  If its something like [69000, 71000]
it returns [70000].</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>array of rounded frequencies</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_soundings_in_polygon">
<span class="sig-name descname"><span class="pre">return_soundings_in_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geographic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_selection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('head',</span> <span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z',</span> <span class="pre">'tvu',</span> <span class="pre">'detectioninfo',</span> <span class="pre">'time',</span> <span class="pre">'beam')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isolate_head</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_soundings_in_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Using provided coordinates (in either horizontal_crs projected or geographic coordinates), return the soundings
and sounding attributes for all soundings within the coordinates, see subset module.  Also sets the ping_filter
attribute which can be used with set_variable_by_filter get_variable_by_filter</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_total_pings">
<span class="sig-name descname"><span class="pre">return_total_pings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_total_pings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total ping count, optionally within the provided mintime maxtime range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – the minimum time desired from the raw_ping dataset</p></li>
<li><p><strong>max_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – the maximum time desired from the raw_ping dataset</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>total number of pings for this dataset</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_total_soundings">
<span class="sig-name descname"><span class="pre">return_total_soundings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_total_soundings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of soundings in all systems within this fqpr instance, optionally within the provided mintime maxtime range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – the minimum time desired from the raw_ping dataset</p></li>
<li><p><strong>max_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – the maximum time desired from the raw_ping dataset</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>total number of soundings in the dataset</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.return_unique_mode">
<span class="sig-name descname"><span class="pre">return_unique_mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.return_unique_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the unique mode entries in raw_ping Datasets.  If there is more than one unique mode, return them in order
of most often found.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>array of mode settings</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.run_filter">
<span class="sig-name descname"><span class="pre">run_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filtername</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selected_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_to_disk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.run_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the filter module with the provided filtername, will match the filename of the filter python file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filtername</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the file that you want to load</p></li>
<li><p><strong>selected_index</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – optional list of 1d boolean arrays representing the flattened index of those values to retain.  Used mainly
in Points View filtering, where you have a (time,beam) space but only want to retain the beams shown in
Points View.</p></li>
<li><p><strong>save_to_disk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True, will save the new sounding status to disk</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.set_filter_by_polygon">
<span class="sig-name descname"><span class="pre">set_filter_by_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geographic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.set_filter_by_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative way to set the ping_filter attribute which can be used with set_variable_by_filter
get_variable_by_filter, see subset module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.set_variable_by_filter">
<span class="sig-name descname"><span class="pre">set_variable_by_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'detectioninfo'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selected_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.set_variable_by_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>ping_filter is set upon selecting points in 2d/3d in Kluster.  See return_soundings_in_polygon.  Here we can take
those points and set one of the variables with new data.  Optionally, you can include a selected_index that is a list
of flattened indices to points in the ping_filter that you want to super-select, see subset module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.set_vertical_reference">
<span class="sig-name descname"><span class="pre">set_vertical_reference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vert_ref</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.set_vertical_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Fqpr instance vertical reference.  This will feed into the georef and calculate tpu processes.</p>
<p>If the new vert_ref conflicts with an existing written vert_ref, issue a warning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vert_ref</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – vertical reference for the survey, one of [‘ellipse’, ‘waterline’, ‘NOAA MLLW’, ‘NOAA MHW’, ‘Aviso MLLW’]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.subset_by_lines">
<span class="sig-name descname"><span class="pre">subset_by_lines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Use subset module to trim the fqpr instance to the given lines</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.subset_by_time">
<span class="sig-name descname"><span class="pre">subset_by_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mintime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Use subset module to trim the fqpr instance to the given time range</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.subset_by_time_and_beam">
<span class="sig-name descname"><span class="pre">subset_by_time_and_beam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset_beam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_time_and_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Use subset module to subset by time,beam provided, returns a 1d boolean mask for each sonar head</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.subset_by_times">
<span class="sig-name descname"><span class="pre">subset_by_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_segments</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_by_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Use subset module to trim the fqpr instance to the given time ranges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.subset_variables">
<span class="sig-name descname"><span class="pre">subset_variables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_selection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ping_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_subset_by_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_detection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Take specific variable names and return just those variables in a new xarray dataset, see subset module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.subset_variables_by_line">
<span class="sig-name descname"><span class="pre">subset_variables_by_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_selection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ping_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_detection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.subset_variables_by_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply subset_variables to get the data split up into lines for the variable_selection provided, see subset module</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.sv_correct">
<span class="sig-name descname"><span class="pre">sv_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">add_cast_files</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_selection_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest_in_time'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.sv_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply sv cast/surface sound speed to raytrace.  Generates xyz for each beam.
Currently only supports nearest-in-time for selecting the cast for each chunk.   Sends the data and
calculations to the cluster, receive futures objects back.  Use the dump_data/delete_futs to interact with
the futures object.</p>
<div class="line-block">
<div class="line">To process only a section of the dataset, use subset_time.</div>
<div class="line">ex: subset_time=[1531317999, 1531321000] means only process times that are from 1531317999 to 1531321000</div>
<div class="line">ex: subset_time=[[1531317999, 1531318885], [1531318886, 1531321000]] means only process times that are
from either 1531317999 to 1531318885 or 1531318886 to 1531321000</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>add_cast_files</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]) – either a list of files to include or the path to a directory containing files.  These are in addition to
the casts in the ping dataset.</p></li>
<li><p><strong>cast_selection_method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – the method used to select the cast that goes with each chunk of the dataset, one of [‘nearest_in_time’,
‘nearest_in_time_four_hours’, ‘nearest_in_distance’, ‘nearest_in_distance_four_hours’]</p></li>
<li><p><strong>subset_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – List of unix timestamps in seconds, used as ranges for times that you want to process.</p></li>
<li><p><strong>dump_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True dump the futures to the multibeam datastore.  Set this to false for an entirely in memory
workflow</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.write_attribute_to_ping_records">
<span class="sig-name descname"><span class="pre">write_attribute_to_ping_records</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.write_attribute_to_ping_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method that allows you to write the provided attribute dictionary to each ping dataset and change
the currently loaded instance as well</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>attr_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – dictionary of attributes that you want stored in the ping datasets</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.fqpr_generation.Fqpr.write_intermediate_futs_to_zarr">
<span class="sig-name descname"><span class="pre">write_intermediate_futs_to_zarr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sys_ident</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestmp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.fqpr_generation.Fqpr.write_intermediate_futs_to_zarr" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush some of the intermediate data that was mapped to the cluster (and lives in futures objects) to disk, puts
it in the multibeam, as the time dimension should be the same.  Mode allows for selecting the output from one
of the main processes for writing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – one of [‘orientation’, ‘bpv’, sv_corr’, ‘georef’, ‘tpu’]</p></li>
<li><p><strong>sys_ident</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – the multibeam system identifier attribute, used as a key to find the intermediate data</p></li>
<li><p><strong>timestmp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – timestamp of the installation parameters instance used</p></li>
<li><p><strong>skip_dask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True will not use the dask.distributed client to submit tasks, will run locally instead</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">kluster</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/index.html">Quickstart - Basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart_monitor/index.html">Quickstart - Monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vessel_setup/index.html">Vessel Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../processing/index.html">Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../surface/index.html">Surfacing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sonar_acceptance/index.html">Sonar Acceptance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cleaning/index.html">Cleaning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../products/index.html">Products</a></li>
<li class="toctree-l1"><a class="reference internal" href="../settings/index.html">Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../indepth/index.html">Learn more about Kluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../for_developers/index.html">For Developers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../kluster_api/index.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_convenience.html">fqpr_convenience module</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../kluster_api/fqpr_generation.html">fqpr_generation module</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../kluster_api/fqpr_generation.html#module-HSTB.kluster.fqpr_generation">HSTB.kluster.fqpr_generation Module</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../kluster_api/fqpr_generation.html#functions">Functions</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../kluster_api/fqpr_generation.html#classes">Classes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_project.html">fqpr_project module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_intelligence.html">fqpr_intelligence module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_actions.html">fqpr_actions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_vessel.html">fqpr_vessel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/monitor.html">monitor module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/xarray_conversion.html">xarray_conversion module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/orientation.html">orientation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/beampointingvector.html">beampointingvector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/svcorrect.html">svcorrect module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/georeference.html">georeference module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/tpu.html">tpu module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/visualizations.html">visualizations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/sat.html">sat module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/wobble.html">wobble module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/export.html">export module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/subset.html">subset module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/rotations.html">rotations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/pdal_entwine.html">pdal_entwine module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/dask_helpers.html">dask_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_helpers.html">fqpr_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/gdal_helpers.html">gdal_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/numba_helpers.html">numba_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/pydro_helpers.html">pydro_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/xarray_helpers.html">xarray_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/utc_helpers.html">utc_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/logging_conf.html">logging_conf module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Changes List</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../kluster_api/index.html">API</a><ul>
  <li><a href="../kluster_api/fqpr_generation.html">fqpr_generation module</a><ul>
      <li>Previous: <a href="HSTB.kluster.fqpr_generation.validate_kluster_input_datum.html" title="previous chapter">validate_kluster_input_datum</a></li>
      <li>Next: <a href="../kluster_api/fqpr_project.html" title="next chapter">fqpr_project module</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Eric Younkin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/HSTB.kluster.fqpr_generation.Fqpr.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>