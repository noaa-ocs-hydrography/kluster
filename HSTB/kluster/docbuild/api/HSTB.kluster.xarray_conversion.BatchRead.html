
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>BatchRead &#8212; kluster 1.1.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="orientation module" href="../kluster_api/orientation.html" />
    <link rel="prev" title="sort_and_drop_duplicates" href="HSTB.kluster.xarray_conversion.sort_and_drop_duplicates.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="batchread">
<h1>BatchRead<a class="headerlink" href="#batchread" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">HSTB.kluster.xarray_conversion.</span></span><span class="sig-name descname"><span class="pre">BatchRead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filfolder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minchunksize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40000000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'zarr'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dashboard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">HSTB.kluster.backends._zarr.ZarrBackend</span></code></p>
<p>BatchRead - multibeam data converter using dask infrastructure and xarray data types
Pass in multibeam files, call read(), and gain access to xarray Datasets for each data type</p>
<p>NOTE: CURRENTLY ONLY ZARR BASED PROCESSING OF kluster_variables.supported_sonar FILES IS SUPPORTED</p>
<div class="line-block">
<div class="line">BatchRead is stored internally using the following conventions:</div>
<div class="line">X = + Forward, Y = + Starboard, Z = + Down</div>
<div class="line">roll = + Port Up, pitch = + Bow Up, gyro = + Clockwise</div>
</div>
<div class="line-block">
<div class="line">&gt;&gt; from xarray_conversion import BatchRead</div>
<div class="line">&gt;&gt; converted = BatchRead(r’C:/data_dir/0009_20170523_181119_FA2806.all’)</div>
<div class="line">Started local cluster client…</div>
<div class="line">&lt;Client: ‘<a class="reference external" href="tcp://127.0.0.1:62327">tcp://127.0.0.1:62327</a>’ processes=4 threads=16, memory=34.27 GB&gt;</div>
<div class="line">&gt;&gt; converted.read()</div>
</div>
<div class="line-block">
<div class="line-block">
<div class="line">Running Kongsberg .all converter</div>
</div>
<div class="line">C:/data_dir/0009_20170523_181119_FA2806.all: Using 20 chunks of size 1962957</div>
<div class="line">Operating on sector 0, s/n 40111, freq 265000</div>
<div class="line">Rebalancing 108 total ping records across 1 blocks of size 1000</div>
<div class="line">Operating on sector 0, s/n 40111, freq 275000</div>
<div class="line">Rebalancing 108 total ping records across 1 blocks of size 1000</div>
<div class="line">Operating on sector 1, s/n 40111, freq 285000</div>
<div class="line">Rebalancing 108 total ping records across 1 blocks of size 1000</div>
<div class="line">Operating on sector 1, s/n 40111, freq 290000</div>
<div class="line">Rebalancing 108 total ping records across 1 blocks of size 1000</div>
<div class="line">Operating on sector 2, s/n 40111, freq 270000</div>
<div class="line">Rebalancing 108 total ping records across 1 blocks of size 1000</div>
<div class="line">Operating on sector 2, s/n 40111, freq 280000</div>
<div class="line">Rebalancing 108 total ping records across 1 blocks of size 1000</div>
<div class="line">Rebalancing 5302 total attitude records across 1 blocks of size 20000</div>
<div class="line-block">
<div class="line">Distributed conversion complete: 5.3s****</div>
</div>
<div class="line">Constructed offsets successfully</div>
<div class="line">read successful</div>
</div>
<div class="line-block">
<div class="line"># examine the serial number/sector/frequency combinations</div>
<div class="line">&gt;&gt; [cnv.sector_identifier for cnv in converted.raw_ping]</div>
</div>
<div class="line-block">
<div class="line">[‘40111_0_265000’,</div>
<div class="line-block">
<div class="line">‘40111_0_275000’,</div>
<div class="line">‘40111_1_285000’,</div>
<div class="line">‘40111_1_290000’,</div>
<div class="line">‘40111_2_270000’,</div>
<div class="line">‘40111_2_280000’]</div>
</div>
</div>
<div class="line-block">
<div class="line"># display the first ping dataset (serial number 40111, sector 0, frequency 265khz)</div>
<div class="line">&gt;&gt; converted.raw_ping[0]</div>
</div>
<div class="line-block">
<div class="line">&lt;xarray.Dataset&gt;</div>
<div class="line">Dimensions:            (beam: 182, time: 108)</div>
<div class="line">Coordinates:</div>
<div class="line-block">
<div class="line">* beam               (beam) int32 0 1 2 3 4 5 6 … 176 177 178 179 180 181</div>
<div class="line">* time               (time) float64 1.496e+09 1.496e+09 … 1.496e+09</div>
</div>
<div class="line">Data variables:</div>
<div class="line-block">
<div class="line">beampointingangle  (time, beam) float32 dask.array&lt;chunksize=(108, 182), meta=np.ndarray&gt;</div>
<div class="line">counter            (time) uint16 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
<div class="line">detectioninfo      (time, beam) int32 dask.array&lt;chunksize=(108, 182), meta=np.ndarray&gt;</div>
<div class="line">mode               (time) &lt;U2 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
<div class="line">modetwo            (time) &lt;U4 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
<div class="line">ntx                (time) uint16 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
<div class="line">qualityfactor      (time, beam) int32 dask.array&lt;chunksize=(108, 182), meta=np.ndarray&gt;</div>
<div class="line">soundspeed         (time) float32 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
<div class="line">tiltangle          (time) float32 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
<div class="line">traveltime         (time, beam) float32 dask.array&lt;chunksize=(108, 182), meta=np.ndarray&gt;</div>
<div class="line">yawpitchstab       (time) &lt;U2 dask.array&lt;chunksize=(108,), meta=np.ndarray&gt;</div>
</div>
<div class="line">Attributes:</div>
<div class="line-block">
<div class="line">_conversion_complete:            Tue Oct 20 15:53:34 2020</div>
<div class="line">installsettings_1495563079:      {“waterline_vertical_location”: “-0.640”…</div>
<div class="line">multibeam_files:                 {‘0009_20170523_181119_FA2806.all’: [149…</div>
<div class="line">output_path:                     C:collabdasktestdata_dirEM2040_small…</div>
<div class="line">profile_1495563079:              [[0.0, 1489.2000732421875], [0.32, 1489….</div>
<div class="line">reference:                       {‘beampointingangle’: ‘receiver’, ‘tilta…</div>
<div class="line">runtimesettings_1495563080:      {“Counter”: “61968”, “SystemSerial#”: “4…</div>
<div class="line">secondary_system_serial_number:  [0]</div>
<div class="line">sector_identifier:               40111_0_265000</div>
<div class="line">survey_number:                   [‘01_Patchtest_2806’]</div>
<div class="line">system_serial_number:            [40111]</div>
<div class="line">units:                           {‘beampointingangle’: ‘degrees’, ‘tiltan…</div>
<div class="line">xyzrph:                          {‘antenna_x’: {‘1495563079’: ‘0.000’}, ‘…</div>
</div>
</div>
<p class="rubric">Attributes Summary</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.chunk_size" title="HSTB.kluster.xarray_conversion.BatchRead.chunk_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chunk_size</span></code></a></p></td>
<td><p>Return the chunk size of the dataset for (time, beam)</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Summary</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.batch_read" title="HSTB.kluster.xarray_conversion.BatchRead.batch_read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_read</span></code></a>([output_mode])</p></td>
<td><p>General converter for multibeam files leveraging xarray and dask.distributed See batch_read, same process but working on memory efficiency</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.build_additional_line_metadata" title="HSTB.kluster.xarray_conversion.BatchRead.build_additional_line_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_additional_line_metadata</span></code></a>([save_pths])</p></td>
<td><p>After conversion, we run this additional step to build the line specific values to store as metadata.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.build_offsets" title="HSTB.kluster.xarray_conversion.BatchRead.build_offsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">build_offsets</span></code></a>([save_pths])</p></td>
<td><p>Form sorteddict for unique entries in installation parameters across all lines, retaining the xyzrph for each transducer/receiver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.correct_for_counter_reset" title="HSTB.kluster.xarray_conversion.BatchRead.correct_for_counter_reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correct_for_counter_reset</span></code></a>()</p></td>
<td><p>Ping counter (at least with the Kongsberg systems) is a 16 bit unsigned integer that will just reset once it reaches 65536.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.get_nearest_install_parameters" title="HSTB.kluster.xarray_conversion.BatchRead.get_nearest_install_parameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_nearest_install_parameters</span></code></a>(query_time)</p></td>
<td><p>Return the install parameters dict object that is nearest in time to query_time</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.get_nearest_runtime_parameters" title="HSTB.kluster.xarray_conversion.BatchRead.get_nearest_runtime_parameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_nearest_runtime_parameters</span></code></a>(query_time)</p></td>
<td><p>Return the runtime parameters dict object that is nearest in time to query_time</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.initialize_log" title="HSTB.kluster.xarray_conversion.BatchRead.initialize_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_log</span></code></a>()</p></td>
<td><p>Initialize the logger, which writes to logfile, that is made at the root folder housing the converted data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.is_dual_head" title="HSTB.kluster.xarray_conversion.BatchRead.is_dual_head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_dual_head</span></code></a>()</p></td>
<td><p>Use the xyzrph keys to determine if sonar is dual head.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.read" title="HSTB.kluster.xarray_conversion.BatchRead.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a>([build_offsets])</p></td>
<td><p>Run the batch_read method on all available lines, writes to datastore (netcdf/zarr depending on self.filtype), and loads the data back into the class as self.raw_ping, self.raw_att.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.read_from_netcdf_fils" title="HSTB.kluster.xarray_conversion.BatchRead.read_from_netcdf_fils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_netcdf_fils</span></code></a>(ping_pths, attitude_pths)</p></td>
<td><p>Read from the generated netCDF files constructed with read()</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.read_from_zarr_fils" title="HSTB.kluster.xarray_conversion.BatchRead.read_from_zarr_fils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_from_zarr_fils</span></code></a>(ping_pth, attitude_pth, ...)</p></td>
<td><p>Read from the generated zarr datastores constructed with read()</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.reload_attituderecords" title="HSTB.kluster.xarray_conversion.BatchRead.reload_attituderecords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reload_attituderecords</span></code></a>([skip_dask])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.reload_pingrecords" title="HSTB.kluster.xarray_conversion.BatchRead.reload_pingrecords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reload_pingrecords</span></code></a>([skip_dask])</p></td>
<td><p>After writing new data to the zarr data store, you need to refresh the xarray Dataset object so that it sees the changes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_all_profiles" title="HSTB.kluster.xarray_conversion.BatchRead.return_all_profiles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_all_profiles</span></code></a>()</p></td>
<td><p>Return dict of attribute_name/data for each sv profile in the ping dataset</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_nearest_soundspeed_profile" title="HSTB.kluster.xarray_conversion.BatchRead.return_nearest_soundspeed_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_nearest_soundspeed_profile</span></code></a>(time_idx)</p></td>
<td><p>Using the settings_xxxxx attribute in the xarray dataset and a given timestamp, return the waterline offset (relative to the tx) nearest in time to the timestamp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_ping_counters_at_time" title="HSTB.kluster.xarray_conversion.BatchRead.return_ping_counters_at_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_ping_counters_at_time</span></code></a>(tme)</p></td>
<td><p>Accepts times as float or a numpy array of times</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_prefix_for_rp" title="HSTB.kluster.xarray_conversion.BatchRead.return_prefix_for_rp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_prefix_for_rp</span></code></a>()</p></td>
<td><p>Determine the correct prefix index based on the sonar reference point of this converted data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_raw_navigation" title="HSTB.kluster.xarray_conversion.BatchRead.return_raw_navigation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_raw_navigation</span></code></a>([start_time, end_time])</p></td>
<td><p>Return just the navigation side of the first ping record.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_runtime_and_installation_settings_dicts" title="HSTB.kluster.xarray_conversion.BatchRead.return_runtime_and_installation_settings_dicts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_runtime_and_installation_settings_dicts</span></code></a>()</p></td>
<td><p>installation and runtime parameters are saved as string (json.dumps) as attributes in each raw_ping dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_rx_xyzrph" title="HSTB.kluster.xarray_conversion.BatchRead.return_rx_xyzrph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_rx_xyzrph</span></code></a>(time_idx)</p></td>
<td><p>Using the constructed xyzrph attribute (see build_offsets) and a given timestamp, return the receiver offsets and angles nearest in time to the timestamp</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_system_time_indexed_array" title="HSTB.kluster.xarray_conversion.BatchRead.return_system_time_indexed_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_system_time_indexed_array</span></code></a>([subset_time])</p></td>
<td><p>Most of the processing involves matching static, timestamped offsets or angles to time series data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_tpu_parameters" title="HSTB.kluster.xarray_conversion.BatchRead.return_tpu_parameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_tpu_parameters</span></code></a>(timestamp)</p></td>
<td><p>Pull out the tpu parameters from the xyzrph installation parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_tx_xyzrph" title="HSTB.kluster.xarray_conversion.BatchRead.return_tx_xyzrph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_tx_xyzrph</span></code></a>(time_idx)</p></td>
<td><p>Using the constructed xyzrph attribute (see build_offsets) and a given timestamp, return the transmitter offsets and angles nearest in time to the timestamp</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_utm_zone_number" title="HSTB.kluster.xarray_conversion.BatchRead.return_utm_zone_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_utm_zone_number</span></code></a>()</p></td>
<td><p>Get the minimum/maximum longitude values and return the utm zone number</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_waterline" title="HSTB.kluster.xarray_conversion.BatchRead.return_waterline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_waterline</span></code></a>(time_idx)</p></td>
<td><p>Using the settings_xxxxx attribute in the xarray dataset and a given timestamp, return the waterline offset (relative to the tx) nearest in time to the timestamp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_xyz_prefixes_for_systems" title="HSTB.kluster.xarray_conversion.BatchRead.return_xyz_prefixes_for_systems"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_xyz_prefixes_for_systems</span></code></a>()</p></td>
<td><p>self.raw_ping contains Datasets broken up by system.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#HSTB.kluster.xarray_conversion.BatchRead.return_xyzrph_sorted_timestamps" title="HSTB.kluster.xarray_conversion.BatchRead.return_xyzrph_sorted_timestamps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">return_xyzrph_sorted_timestamps</span></code></a>(ky)</p></td>
<td><p>Takes in key name and outputs a list of sorted timestamps that are valid for that key.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes Documentation</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.chunk_size">
<span class="sig-name descname"><span class="pre">chunk_size</span></span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunk size of the dataset for (time, beam)</p>
</dd></dl>

<p class="rubric">Methods Documentation</p>
<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.batch_read">
<span class="sig-name descname"><span class="pre">batch_read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'zarr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.batch_read" title="Permalink to this definition">¶</a></dt>
<dd><p>General converter for multibeam files leveraging xarray and dask.distributed
See batch_read, same process but working on memory efficiency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>output_mode</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – ‘zarr’ or ‘netcdf’, zarr is the only currently supported mode, alters the output datastore</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>nested dictionary for each type (ping, attitude, navigation) with path to written data and metadata</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.build_additional_line_metadata">
<span class="sig-name descname"><span class="pre">build_additional_line_metadata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_pths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.build_additional_line_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>After conversion, we run this additional step to build the line specific values to store as metadata.  The end result
is a ‘multibeam_files’ attribute that stores [mintime, maxtime, start_latitude, start_longitude, end_latitude,
end_longitude, azimuth, distance]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>save_pths</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – a list of paths to zarr datastores for writing the multibeam_files attribute to if provided</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.build_offsets">
<span class="sig-name descname"><span class="pre">build_offsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_pths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.build_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Form sorteddict for unique entries in installation parameters across all lines, retaining the xyzrph for each
transducer/receiver.  key values depend on type of sonar, see sonar_translator</p>
<p>Modifies the xyzrph attribute with timestamp dictionary of entries</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>save_pths</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – a list of paths to zarr datastores for writing the xyzrph attribute to if provided</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.correct_for_counter_reset">
<span class="sig-name descname"><span class="pre">correct_for_counter_reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.correct_for_counter_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Ping counter (at least with the Kongsberg systems) is a 16 bit unsigned integer that will just reset once it
reaches 65536.  This zero crossing can happen multiple times in a kluster dataset, as it comprises multiple
survey lines.  We need to handle this by reading it as a larger datatype (int64) and add the int16 limit
whenever it is reached in the counter record.  This should transform a sawtooth record into a smooth,
unique array of values.</p>
<p>fqpr_generation.reform_2d_vars_across_sectors_at_time, reform_1d_vars_across_sectors_at_time will use this
method automatically.  Having duplicate ping counters will mess up the logic we use to reform pings from
these sector based datasets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.get_nearest_install_parameters">
<span class="sig-name descname"><span class="pre">get_nearest_install_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query_time</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.get_nearest_install_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the install parameters dict object that is nearest in time to query_time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_time</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – time in UTC seconds that you need the nearest install parameters to</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>install parameters dict object that is nearest in time to the query time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.get_nearest_runtime_parameters">
<span class="sig-name descname"><span class="pre">get_nearest_runtime_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query_time</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.get_nearest_runtime_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the runtime parameters dict object that is nearest in time to query_time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_time</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – time in UTC seconds that you need the nearest runtime parameters to</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>runtime parameters dict object that is nearest in time to the query time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.initialize_log">
<span class="sig-name descname"><span class="pre">initialize_log</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.initialize_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the logger, which writes to logfile, that is made at the root folder housing the converted data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.is_dual_head">
<span class="sig-name descname"><span class="pre">is_dual_head</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.is_dual_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the xyzrph keys to determine if sonar is dual head.  Port/Starboard identifiers will exist if dual.
Kongsberg writes both heads to one file, only identifiable by serial number (each head will have a different
serial number)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if dual head, False if not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">build_offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the batch_read method on all available lines, writes to datastore (netcdf/zarr depending on self.filtype),
and loads the data back into the class as self.raw_ping, self.raw_att.</p>
<p>If data loads correctly, builds out the self.xyzrph attribute and translates the runtime parameters to a usable
form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>build_offsets</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if this is set, also build the xyzrph attribute, which is mandatory for processing later in Kluster.  Make
it optional so that when processing chunks of files, we can just run it once at the end after read()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.read_from_netcdf_fils">
<span class="sig-name descname"><span class="pre">read_from_netcdf_fils</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ping_pths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attitude_pths</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.read_from_netcdf_fils" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the generated netCDF files constructed with read()</p>
<p><strong>Currently some issues with open_mfdataset that I’ve not resolved.  Using it with the dask distributed
cluster active results in worker errors/hdf errors.  Using it without the distributed cluster works fine.  So
annoying.  I’m sticking to the zarr stuff for now, distributed parallel read/writes appear to work there after
I built my own writer.</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ping_pths</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – paths to the ping netcdf files</p></li>
<li><p><strong>attitude_pths</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – path to the attitude netcdf files</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.read_from_zarr_fils">
<span class="sig-name descname"><span class="pre">read_from_zarr_fils</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ping_pth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attitude_pth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfile_pth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.read_from_zarr_fils" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the generated zarr datastores constructed with read()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ping_pth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>) – list of paths to each ping zarr group (by system)</p></li>
<li><p><strong>attitude_pth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – path to the attitude zarr group</p></li>
<li><p><strong>logfile_pth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – path to the text log file used by logging</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.reload_attituderecords">
<span class="sig-name descname"><span class="pre">reload_attituderecords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">skip_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.reload_attituderecords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.reload_pingrecords">
<span class="sig-name descname"><span class="pre">reload_pingrecords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">skip_dask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.reload_pingrecords" title="Permalink to this definition">¶</a></dt>
<dd><p>After writing new data to the zarr data store, you need to refresh the xarray Dataset object so that it
sees the changes.  We do that here by just re-running open_zarr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>skip_dask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – if True will skip the dask distributd client stuff when reloading</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_all_profiles">
<span class="sig-name descname"><span class="pre">return_all_profiles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_all_profiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dict of attribute_name/data for each sv profile in the ping dataset</p>
<p>attribute name is always ‘profile_timestamp’ format, ex: ‘profile_1503411780’</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>list</em> – list of profile names</p></li>
<li><p><em>list</em> – list of [depth values, sv values] for each profile</p></li>
<li><p><em>list</em> – list of times in utc seconds for each profile</p></li>
<li><p><em>list</em> – list of [latitude, longitude] for each profile</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_nearest_soundspeed_profile">
<span class="sig-name descname"><span class="pre">return_nearest_soundspeed_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_nearest_soundspeed_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the settings_xxxxx attribute in the xarray dataset and a given timestamp, return the waterline
offset (relative to the tx) nearest in time to the timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_idx</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – UTC timestamp (accepts int/str/float)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>key = closest timestamp and value = waterline offset</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_ping_counters_at_time">
<span class="sig-name descname"><span class="pre">return_ping_counters_at_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tme</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_ping_counters_at_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepts times as float or a numpy array of times</p>
<p>To rebuild the full ping at a specific time, you need to get the ping counter(s) at that time.  EM2040c
have multiple pings at a specific time, so this will return a list of counters that is usually only one
element long.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tme</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code>]) – float or numpy array, time to find ping counters for</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of ints for ping counter numbers at that time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>cntrs</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_prefix_for_rp">
<span class="sig-name descname"><span class="pre">return_prefix_for_rp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_prefix_for_rp" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the correct prefix index based on the sonar reference point of this converted data.  For instance,
if the sonar reference point is [‘tx_x’, ‘tx_y’, ‘rx_z’], the returned prefix indices would be [0,0,1], which
will allow you to pull the correct lever arms from the xyzrph indices. See return_system_time_indexed_array.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_raw_navigation">
<span class="sig-name descname"><span class="pre">return_raw_navigation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_raw_navigation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return just the navigation side of the first ping record.  If a start time and end time are provided, will
subset to just those times.</p>
<p>If this is a dual head sonar, it only returns the nav for the first head!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – if provided will allow you to only return navigation after this time.  Selects the nearest time value to
the one provided.</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – if provided will allow you to only return navigation before this time.  Selects the nearest time value to
the one provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>latitude/longitude/altitude pulled from the raw navigation part of the ping record</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_runtime_and_installation_settings_dicts">
<span class="sig-name descname"><span class="pre">return_runtime_and_installation_settings_dicts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_runtime_and_installation_settings_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>installation and runtime parameters are saved as string (json.dumps) as attributes in each raw_ping
dataset.  Use this method to return the dicts that encompass each installation and runtime entry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_rx_xyzrph">
<span class="sig-name descname"><span class="pre">return_rx_xyzrph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_rx_xyzrph" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the constructed xyzrph attribute (see build_offsets) and a given timestamp, return the
receiver offsets and angles nearest in time to the timestamp</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_idx</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – UTC timestamp (accepts int/str/float)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>key = closest timestamp and values = mounting angle/offsets for receiver</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_system_time_indexed_array">
<span class="sig-name descname"><span class="pre">return_system_time_indexed_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_system_time_indexed_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Most of the processing involves matching static, timestamped offsets or angles to time series data.  Given that
we might have a list of systems for dual head sonar and a list of timestamped offsets, need to iterate through
all of this in each processing loop.  Systems/timestamps length should be minimal, so we just loop in python.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>subset_time</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>]) – List of unix timestamps in seconds, used as ranges for times that you want to process</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of indices for each system/timestamped offsets that are within the provided subset.  length of the list
is the number of heads for this sonar.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_tpu_parameters">
<span class="sig-name descname"><span class="pre">return_tpu_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timestamp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_tpu_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull out the tpu parameters from the xyzrph installation parameters.  We need these parameters to compute tpu.
Only pulls the values for a single timestamped entry, using the provided timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – utc time in seconds for the entry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dict of tpu parameters for the timestamped entry</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_tx_xyzrph">
<span class="sig-name descname"><span class="pre">return_tx_xyzrph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_tx_xyzrph" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the constructed xyzrph attribute (see build_offsets) and a given timestamp, return the
transmitter offsets and angles nearest in time to the timestamp</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_idx</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – UTC timestamp (accepts int/str/float)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>key = closest timestamp and values = mounting angle/offsets for receiver</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_utm_zone_number">
<span class="sig-name descname"><span class="pre">return_utm_zone_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_utm_zone_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum/maximum longitude values and return the utm zone number</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>zone number, e.g. ‘19N’ for UTM Zone 19 N</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_waterline">
<span class="sig-name descname"><span class="pre">return_waterline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_waterline" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the settings_xxxxx attribute in the xarray dataset and a given timestamp, return the waterline
offset (relative to the tx) nearest in time to the timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time_idx</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – UTC timestamp (accepts int/str/float)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>key = closest timestamp and value = waterline offset</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_xyz_prefixes_for_systems">
<span class="sig-name descname"><span class="pre">return_xyz_prefixes_for_systems</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_xyz_prefixes_for_systems" title="Permalink to this definition">¶</a></dt>
<dd><p>self.raw_ping contains Datasets broken up by system.  This method will return the prefixes you need to get
the offsets/angles from self.xyzrph depending on dual-head</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of two element lists containing the prefixes needed for tx/rx offsets and angles</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="HSTB.kluster.xarray_conversion.BatchRead.return_xyzrph_sorted_timestamps">
<span class="sig-name descname"><span class="pre">return_xyzrph_sorted_timestamps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ky</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#HSTB.kluster.xarray_conversion.BatchRead.return_xyzrph_sorted_timestamps" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes in key name and outputs a list of sorted timestamps that are valid for that key.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ky</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – key name that you want the timestamps from (i.e. ‘tx_x’)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sorted timestamps of type str, in increasing order</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">kluster</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/index.html">Quickstart - Basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart_monitor/index.html">Quickstart - Monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vessel_setup/index.html">Vessel Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../processing/index.html">Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../surface/index.html">Surfacing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mosaic/index.html">Backscatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sonar_acceptance/index.html">Sonar Acceptance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cleaning/index.html">Cleaning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../products/index.html">Products</a></li>
<li class="toctree-l1"><a class="reference internal" href="../settings/index.html">Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../indepth/index.html">Learn more about Kluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../for_developers/index.html">For Developers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../kluster_api/index.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_convenience.html">fqpr_convenience module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_generation.html">fqpr_generation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_project.html">fqpr_project module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_intelligence.html">fqpr_intelligence module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_actions.html">fqpr_actions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_vessel.html">fqpr_vessel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/monitor.html">monitor module</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../kluster_api/xarray_conversion.html">xarray_conversion module</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../kluster_api/xarray_conversion.html#module-HSTB.kluster.xarray_conversion">HSTB.kluster.xarray_conversion Module</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../kluster_api/xarray_conversion.html#functions">Functions</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../kluster_api/xarray_conversion.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kluster_api/xarray_conversion.html#class-inheritance-diagram">Class Inheritance Diagram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/orientation.html">orientation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/beampointingvector.html">beampointingvector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/svcorrect.html">svcorrect module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/georeference.html">georeference module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/tpu.html">tpu module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/backscatter.html">backscatter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/visualizations.html">visualizations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/sat.html">sat module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/wobble.html">wobble module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/export.html">export module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/subset.html">subset module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/rotations.html">rotations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/pdal_entwine.html">pdal_entwine module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/dask_helpers.html">dask_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/fqpr_helpers.html">fqpr_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/gdal_helpers.html">gdal_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/numba_helpers.html">numba_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/pydro_helpers.html">pydro_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/xarray_helpers.html">xarray_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/utc_helpers.html">utc_helpers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kluster_api/logging_conf.html">logging_conf module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Changes List</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../kluster_api/index.html">API</a><ul>
  <li><a href="../kluster_api/xarray_conversion.html">xarray_conversion module</a><ul>
      <li>Previous: <a href="HSTB.kluster.xarray_conversion.sort_and_drop_duplicates.html" title="previous chapter">sort_and_drop_duplicates</a></li>
      <li>Next: <a href="../kluster_api/orientation.html" title="next chapter">orientation module</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Eric Younkin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/HSTB.kluster.xarray_conversion.BatchRead.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>